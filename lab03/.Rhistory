createPath <- function(df){
# Given x and y coordinates creates a string containing a svg path
# that can be fed to plotly as a shape
start <- paste("M", df$x[1], df$y[1])
path <- paste("L", df$x[-1], df$y[-1], collapse = " ")
path <- paste(start, path, "Z")
return(path)
}
# Use group numbers assigned to each sector to subset and create a path string
ideogram.path <- by(ideogram, ideogram$group, createPath)
# Plot the ideogram (just as a check). Chord diagram is generated separately later
# Create shape list
ideogram.shapes <- list()  # Used later on
for (i in 1:nrow(df)) {
# Use plotly syntax to save shapes of each sector as a list
ideogram.shapes[[i]] <- list(type = "path",
path = ideogram.path[i],
fillcolor = cols[i],
line = list(color = linecolor, width = 1),
opacity = opacity)
}
# Just to check if things are looking okay
ideogram.plot <- plot_ly(height = 800, width = 800) %>%
layout(
xaxis = list(showgrid = F, zeroline = F, showticklabels = F),
yaxis = list(showgrid = F, zeroline = F, showticklabels = F),
shapes = ideogram.shapes)
# Create chords ---------------------------------------------------------------
# Divide each sector corresponding to each interaction in each row
sector.angles <- inner$gaps
angle.list <- data.frame()
for (i in 1:nrow(sector.angles)) {
# Get starting and ending points of each sector
start <- sector.angles$start[i]
end <- sector.angles$end[i]
# Sort each row from increasing to decreasing
dat <- sort(df[i,])
# Use toAngular() function to get thetas corresponding to each row item
angle <- toAngular(as.numeric(dat), lower = start, upper = end, addgaps = F)$theta
# Offset by the starting point since the function returns values in
# the [0 - (start - end)] interval
angle <- c(start + angle)
# Collate all the data for each division of the sector
temp <- data.frame(from = rownames(sector.angles)[i],
to = names(dat),
value = as.numeric(dat),
angle,
x = inner.radius * cos(angle),
y = inner.radius * sin(angle),
stringsAsFactors = F)
# Add the starting point to the divisions
# If min value in a row is zero then starting point for that division
# must be the starting point of the sector
startrow <- data.frame(from = rownames(sector.angles)[i],
to = "start",
value = 0,
angle = sector.angles$start[i],
x = inner.radius * cos(sector.angles$start[i]),
y = inner.radius * sin(sector.angles$start[i]),
stringsAsFactors = F)
angle.list <- rbind(angle.list, startrow, temp)
}
# Create unique path IDs i.e. each set of interactions gets a unique ID
# Example - A -> B and B -> A will get the same ID
k <- 1
angle.list$ID <- rep(0, nrow(angle.list))
revstr <- paste(angle.list$to, angle.list$from)
for (i in 1:nrow(angle.list)) {
if (angle.list$ID[i] == 0) {
from = angle.list$from[i]
to = angle.list$to[i]
str <- paste(from, to)
mtch <- match(str, revstr)
if (!is.na(mtch)) {
angle.list$ID[c(i, mtch)] <- k
k <- k + 1
}
}
}
# Each chord is bounded by four points:
# 1. two actual data points corrosponding to the actual interaction i.e. A -> B (p1) and B -> A (p2)
# 2. And two previous data points to complete the polygon
# We'll create some helper functions
# Function definition: bezierCurve() ------------------------------------------
bezierCurve <- function(t1, t2){
# Takes two angles as arguments and returns the x and y coordinates
# of a quadratic bezier curve
t <- seq(0, 1, length.out = 100)
p0 <- c(inner.radius * cos(t1), inner.radius * sin(t1))  # Starting point (t1)
p2 <- c(inner.radius * cos(t2), inner.radius * sin(t2))  # Ending point (t2)
p1 <- c(-inner.radius * cos(mean(t1, t2)), -inner.radius * sin(mean(t1, t2)))  # Control point
# Curve =  (1 - t^2)*p0 + 2(t-1)t*p1 + t^2*p2
x <- (1 - t**2) * p0[1] + 2*(1 - t)*t * p1[1] + t**2 * p2[1]
y <- (1 - t**2) * p0[2] + 2*(1 - t)*t * p1[2] + t**2 * p2[2]
df <- data.frame(x, y)
return(df)
}
# Function definition: circleCurve() ------------------------------------------
circleCurve <- function(t1, t2){
# Returns the x and y coordinates of points lying on the inner
# boundary of the ideogram bounded by two angles t1 and t2
t <- seq(min(t1, t2), max(t1, t2), length.out = 50)
x <- inner.radius * cos(t)
y <- inner.radius * sin(t)
df <- data.frame(x, y)
return(df)
}
# Function definition: opposite() ---------------------------------------------
opposite <- function(df){
# Given a dataframe, simply returns the dataframe in reverse order
n <- nrow(df)
df <- df[n:1,]
return(df)
}
# Function definition: chordShape() -------------------------------------------
chordShape <- function(ID){
# Function to create svg path for a chord given by a unique ID (created earler)
id <- which(angle.list$ID == ID)
# Get color based on higher number of connects
idx <- which.max(angle.list$value[id])
fillcolor <- angle.list$from[id[idx]]
fillcolor <- cols[which(rownames(df) == fillcolor)]
# Append the two prior points to complete polygon
id <- c(id, id - 1)
t <- angle.list$angle[id]
# Each chord is made of two bezier curves and two (one) curve lying on the
# inner boundary of the ideogram
if(length(t) == 4){
a <- bezierCurve(t[1], t[4])
b <- bezierCurve(t[3], t[2])
c <- circleCurve(t[1], t[3])
d <- circleCurve(t[2], t[4])
df <- rbind(a, d, opposite(b), c)
pth <- createPath(df)
shp <- list(type = "path",
path = pth,
fillcolor = fillcolor,
line = list(color = linecolor, width = 1),
opacity = chord.opacity)
}else{
# Case when there are zero interactions i.e.
# A -> B > 0 but B -> A = 0 or viceversa
a <- bezierCurve(t[1], t[2])
b <- circleCurve(t[1], t[2])
df <- rbind(a, b)
pth <- createPath(df)
shp <- list(type = "path",
path = pth,
fillcolor = fillcolor,
line = list(color = linecolor, width = 1),
opacity = chord.opacity)
}
return(shp)
}
# Loop through each unique ID and create a shape for each corrosponding polygon
chord.shapes <- list()
for(i in unique(angle.list$ID)){
if(i != 0){
chord.shapes[[i]] <- chordShape(ID = i)
}
}
# Create a grey circle on the inside for aesthetics
ang <- seq(0, (2*pi), length.out = 100)
x <- 1 * cos(ang)
y <- 1 * sin(ang)
pth <- createPath(df = data.frame(x, y))
inner.circle <- list(list(type = "path",
path = pth,
fillcolor = circlefill,
line = list(color = linecolor, width = 1),
opacity = 0.2))
# Add all shapes to same list
all.shapes <- c(ideogram.shapes, chord.shapes, inner.circle)
length(all.shapes)
# Plot chord diagram ----------------------------------------------------------
# Just a description of chord diagram
# description <- paste0("<i>","Co-ocorrencias entre as empresas","</i>")
# Coordinates for labels
# labels <- data.frame(x = 1.1 * cos(outer$theta - pi/5),
#                      y = 1.1 * sin(outer$theta - pi/5),
#                      text = paste0("<b>", rownames(df), "</b>"))
l <- data.frame(x = c(0.95, 0.99, 0.1, -0.2, 0.89),
y = c(0.05, 0.15, 1.04, -1.09, -0.4),
text = paste0("<b>", rownames(df), "</b>"))
rownames(l) <- rownames(df)
# Plot using plot_ly()
chord.plot <- plot_ly(width = 800, height = 800) %>%
# Add labels to sectors
add_text(data = l, x = ~x, y = ~y, text = ~text, hoverinfo = "none",
textfont = list(family = "serif", size = 14, color = "#999999")) %>%
# Layout for shapes, annotations and axis options
layout(
xaxis = list(title = "", showgrid = F, zeroline = F, showticklabels = F, domain = c(0, 0.9)),
yaxis = list(title = "", showgrid = F, zeroline = F, showticklabels = F, domain = c(0, 0.9)),
shapes = all.shapes,
annotations = list(
list(xref = "paper", yref = "paper",
xanchor = "top", yanchor = "top",
x = 0, y = 1, showarrow = F,
text = "<b>Co-ocorrÃªncias entre as empresas</b>",
font = list(family = "serif", size = 25, color = "black"))))
print(chord.plot)
chordDiagram(df, directional = TRUE, transparency = 0.5)
View(fornecedores)
View(empenhos)
library(methods)
library(dplyr)
library(stringr)
library(rsagrespb)
library(methods)
library(dplyr)
library(stringr)
library(rsagrespb)
query <- sql('SELECT *
FROM Pagamentos')
pagamentos <- tbl(sagres, query) %>%
group_by(cd_UGestora, nu_Empenho, dt_Ano, cd_UnidOrcamentaria) %>%
summarise(total_pag = sum(vl_Pagamento)) %>%
collect(n = Inf)
sagres = src_mysql('SAGRES_MUNICIPAL', group='ministerio-publico', password=NULL)
query <- sql('SELECT *
FROM Pagamentos')
pagamentos <- tbl(sagres, query) %>%
group_by(cd_UGestora, nu_Empenho, dt_Ano, cd_UnidOrcamentaria) %>%
summarise(total_pag = sum(vl_Pagamento)) %>%
collect(n = Inf)
query <- sql('SELECT *
FROM Empenhos')
empenhos <- tbl(sagres, query) %>%
left_join(pagamentos, by = c("cd_UGestora", "nu_Empenho", "dt_Ano", "cd_UnidOrcamentaria")) %>%
mutate(de_Municipio = get.municipio(cd_UGestora)) %>%
group_by(cd_Credor) %>%
summarise(ganhou = n_distinct(cd_UGestora, nu_Licitacao, tp_Licitacao),
municipios_vitorias = n_distinct(de_Municipio),
valor_total_emp = sum(vl_Empenho),
valor_mediana_emp = median(vl_Empenho),
valor_total_pag = sum(total_pag, na.rm = TRUE)) %>%
left_join(empenhos %>% group_by(cd_Credor, no_Credor) %>% distinct(cd_Credor), by = "cd_Credor") %>%
collect(n = Inf)
empenhos <- tbl(sagres, query) %>%
left_join(pagamentos, by = c("cd_UGestora", "nu_Empenho", "dt_Ano", "cd_UnidOrcamentaria")) %>%
mutate(de_Municipio = get.municipio(cd_UGestora)) %>%
group_by(cd_Credor) %>%
summarise(ganhou = n_distinct(cd_UGestora, nu_Licitacao, tp_Licitacao),
municipios_vitorias = n_distinct(de_Municipio),
valor_total_emp = sum(vl_Empenho),
valor_mediana_emp = median(vl_Empenho),
valor_total_pag = sum(total_pag, na.rm = TRUE)) %>%
left_join(empenhos %>% group_by(cd_Credor, no_Credor) %>% distinct(cd_Credor), by = "cd_Credor") %>%
collect(n = Inf)
empenhos <- tbl(sagres, query) %>%
# left_join(pagamentos, by = c("cd_UGestora", "nu_Empenho", "dt_Ano", "cd_UnidOrcamentaria")) %>%
mutate(de_Municipio = get.municipio(cd_UGestora)) %>%
group_by(cd_Credor) %>%
summarise(ganhou = n_distinct(cd_UGestora, nu_Licitacao, tp_Licitacao),
municipios_vitorias = n_distinct(de_Municipio),
valor_total_emp = sum(vl_Empenho),
valor_mediana_emp = median(vl_Empenho),
valor_total_pag = sum(total_pag, na.rm = TRUE)) %>%
left_join(empenhos %>% group_by(cd_Credor, no_Credor) %>% distinct(cd_Credor), by = "cd_Credor") %>%
collect(n = Inf)
empenhos <- tbl(sagres, query) %>%
left_join(pagamentos, by = c("cd_UGestora", "nu_Empenho", "dt_Ano", "cd_UnidOrcamentaria"))
query <- sql('SELECT *
FROM Empenhos')
sagres = src_mysql('SAGRES_MUNICIPAL', group='ministerio-publico', password=NULL)
empenhos <- tbl(sagres, query) %>%
left_join(pagamentos, by = c("cd_UGestora", "nu_Empenho", "dt_Ano", "cd_UnidOrcamentaria"
))
query <- sql('SELECT *
FROM Pagamentos')
pagamentos <- tbl(sagres, query) %>%
group_by(cd_UGestora, nu_Empenho, dt_Ano, cd_UnidOrcamentaria) %>%
summarise(total_pag = sum(vl_Pagamento))
query <- sql('SELECT *
FROM Empenhos')
empenhos <- tbl(sagres, query) %>%
left_join(pagamentos, by = c("cd_UGestora", "nu_Empenho", "dt_Ano", "cd_UnidOrcamentaria")) %>%
mutate(de_Municipio = get.municipio(cd_UGestora)) %>%
group_by(cd_Credor) %>%
summarise(ganhou = n_distinct(cd_UGestora, nu_Licitacao, tp_Licitacao),
municipios_vitorias = n_distinct(de_Municipio),
valor_total_emp = sum(vl_Empenho),
valor_mediana_emp = median(vl_Empenho),
valor_total_pag = sum(total_pag, na.rm = TRUE)) %>%
left_join(empenhos %>% group_by(cd_Credor, no_Credor) %>% distinct(cd_Credor), by = "cd_Credor") %>%
collect(n = Inf)
empenhos <- tbl(sagres, query) %>%
left_join(pagamentos, by = c("cd_UGestora", "nu_Empenho", "dt_Ano", "cd_UnidOrcamentaria"))
empenhos %>%
mutate(de_Municipio = get.municipio(cd_UGestora)) %>%
group_by(cd_Credor) %>%
summarise(ganhou = n_distinct(cd_UGestora, nu_Licitacao, tp_Licitacao),
municipios_vitorias = n_distinct(de_Municipio),
valor_total_emp = sum(vl_Empenho),
valor_mediana_emp = median(vl_Empenho),
valor_total_pag = sum(total_pag, na.rm = TRUE)) %>%
left_join(empenhos %>% group_by(cd_Credor, no_Credor) %>% distinct(cd_Credor), by = "cd_Credor") %>%
collect(n = Inf)
pagamentos %>%
collect(n = Inf)
sagres = src_mysql('SAGRES_MUNICIPAL', group='ministerio-publico', password=NULL)
query <- sql('SELECT cd_UGestora, nu_Empenho, dt_Ano, cd_UnidOrcamentaria, cd_Credor, no_Credor, vl_Empenho, tp_Licitacao, nu_Licitacao
FROM Empenhos')
empenhos <- tbl(sagres, query) %>%
collect(n = Inf)
query <- sql('SELECT cd_UGestora, nu_Empenho, dt_Ano, cd_UnidOrcamentaria, vl_Pagamento
FROM Pagamentos')
pagamentos <- tbl(sagres, query) %>%
group_by(cd_UGestora, nu_Empenho, dt_Ano, cd_UnidOrcamentaria) %>%
summarise(total_pag = sum(vl_Pagamento)) %>%
collect(n = Inf)
empenhos <- empenhos %>%
left_join(pagamentos, by = c("cd_UGestora", "nu_Empenho", "dt_Ano", "cd_UnidOrcamentaria"))
licitacoes <- empenhos %>%
group_by(cd_UGestora, nu_Licitacao, tp_Licitacao) %>%
summarise(total_empenhos = n())
query <- sql('SELECT *
FROM Participantes')
participantes <- tbl(sagres, query) %>%
collect(n = Inf)
query <- sql('SELECT nu_CPFCNPJ, no_Fornecedor
FROM Fornecedores')
fornecedores <- tbl(sagres, query) %>%
collect(n = Inf) %>%
distinct(nu_CPFCNPJ, .keep_all = TRUE)
library(plotly)
load("~/Documents/investigacao-empresas/avaliacao-metricas/.RData")
plot_ly(suspeitos_ano, x = ~ano, y = ~n)
plot_ly(suspeitos_ano, x = ~ano, y = ~n, trace = "bars")
plot_ly(suspeitos_ano, x = ~ano, y = ~n, trace = "bar")
plot_ly(suspeitos_ano, x = ~ano, y = ~n, type = "bar")
plot_ly(suspeitos_ano, x = ~ano, y = ~n, type = "bar") %>%
layout(title = "Suspeitos ou InidÃ´neas por ano",
xaxis = list(title = "Ano"),
yaxis = list(title = "NÃºmero de empresas"))
ggplot(metricas_aval_, aes(x = metrica, y = precisao, color = metrica)) +
geom_point() +
facet_wrap(~ano, ncol = 2) %>%
ggplotly()
ggplotly(ggplot(metricas_aval_, aes(x = metrica, y = precisao, color = metrica)) +
geom_point() +
facet_wrap(~ano, ncol = 2))
prec <- ggplot(metricas_aval_, aes(x = metrica, y = precisao, color = metrica)) +
geom_point() +
facet_wrap(~ano, ncol = 2)
prec %>%
ggplotly()
prec %>%
ggplotly() %>%
layout(title = "PrecisÃ£o das mÃ©tricas 2011-2014",
xaxis = list(title = "Ano"),
yaxis = list(title = "PrecisÃ£o"))
prec %>%
ggplotly() %>%
layout(title = "PrecisÃ£o das mÃ©tricas 2011-2014",
xaxis = list(title = "Ano"),
yaxis = list(title = "MÃ©trica"))
prec %>%
ggplotly() %>%
layout(title = "PrecisÃ£o das mÃ©tricas 2011-2014")
theme_set(theme_bw())
revc <- ggplot(metricas_aval_, aes(x = metrica, y = revocacao, color = metrica)) +
geom_point() +
facet_wrap(~ano, ncol = 2)
revc %>%
ggplotly() %>%
layout(title = "RevocaÃ§Ã£o das mÃ©tricas 2011-2014")
View(suspeitos_ano)
suspeitos_ano <- ceis %>%
filter(UFOrgaoSancionador %in% c("PB", "pb")) %>%
mutate(ano = substr(DataInicioSancao, 7, 10)) %>%
filter(ano <= 2015) %>%
distinct(ano, CPFouCNPJDoSancionado) %>%
group_by(ano) %>%
summarize(n = n())
library(dplyr)
suspeitos_ano <- ceis %>%
filter(UFOrgaoSancionador %in% c("PB", "pb")) %>%
mutate(ano = substr(DataInicioSancao, 7, 10)) %>%
filter(ano <= 2015) %>%
distinct(ano, CPFouCNPJDoSancionado) %>%
group_by(ano) %>%
summarize(n = n())
load("~/Documents/investigacao-empresas/avaliacao-modelos/dados/result_all_2016.RData")
View(result_all_2016)
install.packages("ClusterR")
library(ClusterR)
install.packages("ClusterR")
install.packages("ClusterR", dependencies = TRUE)
install.packages("gtools")
install.packages("ClusterR", dependencies = TRUE)
install.packages(c("Rcpp", "OpenImageR", "graphics", "grDevices", "gmp","FD"))
install.packages(c("Rcpp", "OpenImageR", "graphics", "grDevices", "gmp", "FD"))
install.packages(c("Rcpp", "OpenImageR", "graphics", "grDevices", "gmp", "FD"))
install.packages("Rcpp")
install.packages("OpenImageR")
install.packages("tiff")
install.packages("graphics")
install.packages("grDevices")
install.packages("gmp")
install.packages("FD")
install.packages("ClusterR")
?gtools
??gtools
installed.packages()
install.packages("gtools")
install.packages("RcppArmadillo")
install.packages("FD")
install.packages("Rcpp")
install.packages("OpenImageR")
install.packages("OpenImageR", dependencies = TRUE)
?kmeans
library(tidyverse)
data <- result_all_2016 %>%
select(2,3,4,5,6,8,9)
View(data)
data <- result_all_2016 %>%
select(c(2,3,4,5,6,8,9))
data <- result_all_2016 %>%
select("2")
data <- result_all_2016 %>%
select("2", "3", "4", "5", "6", "8", "9")
data <- result_all_2016 %>%
select("2", "3", "4", "5", "6", "8", "9") %>%
scale()
kmeans(data, 2)
kmeans(data, centers = 2)
data <- result_all_2016 %>%
select("2", "3", "4", "5", "6", "8", "9") %>%
scale(.)
data <- result_all_2016 %>%
select("2", "3", "4", "5", "6", "8", "9")
data <- result_all_2016 %>%
select("2", "3", "4", "5", "6", "8", "9")
data[is.na(data)] <- 0
kmeans(data, centers = 2)
class <- kmeans(data, centers = 2)
plot(class)
plot(class$cluster)
silhouette(class)
autoplot(class, data = data)
km_class <- kmeans(data, centers = 2)
autoplot(km_class, data = data)
km_class$cluster
count(km_class$cluster)
km_class %>%
group_by(cluster) %>%
summarise(n())
a = km_class$cluster
b = km_class$centers
View(b)
result_all_2016 <- result_all_2016 %>%
cbind(km_class$cluster)
View(result_all_2016)
result_all_2016 %>%
group_by(`km_class$cluster`) %>%
summarise(n())
load("~/Documents/investigacao-empresas/avaliacao-modelos/modelo-base/ceis.RData")
View(ceis.u)
result_all_2016 <- result_all_2016 %>%
cbind(km_class$cluster) %>%
mutate(ceis = ifelse(CNPJ %in% ceis.u$CPF.ou.CNPJ.do.Sancionado, 2,1))
load("~/Documents/investigacao-empresas/avaliacao-modelos/dados/result_all_2016.RData")
result_all_2016 <- result_all_2016 %>%
cbind(km_class$cluster) %>%
mutate(ceis = ifelse(CNPJ %in% ceis.u$CPF.ou.CNPJ.do.Sancionado, 2,1))
result_all_2016 %>%
filter(`km_class$cluster` == 2, ceis == 2)
result_all_2016 %>%
filter(`km_class$cluster` == 2, ceis == 2) %>%
select(fornecedor)
View(ceis)
View(ceis.u)
View(result_all_2016)
result_all_2016 %>%
group_by(CNPJ) %>%
summarise(n())
b<- result_all_2016 %>%
group_by(CNPJ) %>%
summarise(n())
View(b)
setwd("~/Documents/ad2/lab03")
library(caret)
library(tidyverse)
dados <- read_csv("train.csv")
dataPartition <- createDataPartition(dados$situacao_final, p = 0.75, list = FALSE)
teste <- dados[dataPartition,]
treino <- dados[-dataPartition,]
ggplot(data=dados, aes(situacao_final)) +
geom_histogram(stat = "count", fill = "#0080ff")
n_eleitos <- dados %>%
filter(situacao_final == "eleito") %>%
nrow()
n_Neleitos <- dados %>%
filter(situacao_final == "nao_eleito") %>%
nrow()
round(n_Neleitos/n_eleitos,2)
ctrl <- trainControl(method = "repeatedcv",
number = 10,
repeats = 5,
summaryFunction = twoClassSummary,
classProbs = TRUE,
sampling = "up")
formula = as.formula(situacao_final ~ .)
modelo_regLog <- train(formula,
data = teste,
method="glm",
family="binomial",
na.action = na.omit,
trControl = ctrl)
View(dados)
